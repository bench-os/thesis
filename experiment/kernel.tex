\section{Integrating the framework in the kernel of the RTOS \label{sec:kernel}}

Our first approach was to implement the framework inside the kernel of the RTOS.
Using this method, we can compute the time it takes for a context switch directly in the scheduler.
In RTOS, when a task goes to the background, the scheduler goes in foreground and resume the next task.
The framework would be able to compute the time between the first and the last call of the scheduler computing this way the context switching time.

\subsection{Motivations}

This approach have some advantages.
First, it make the framework completely hidden for the developer.
This is great because it match one of our criteria for the framework.
The developer could implement its application regardless of the framework operation.
In results, no source code in the user-space should be altered making it possible to use the framework on previously implemented application.
Then, one could use the framework on applications already running in production only by updating the RTOS.

\subsection{Limitations}

However, we choose to abandon the approach of integrating the framework inside the kernel of RIOT OS for the following reasons.
First, we are not sure that if we use this methodology we will measure the real context switching time.
It is possible that some calls or functions are executed before the scheduler and that the framework will not take them into account.

Finally, the scheduler implementation is strongly platform-dependent meaning that every platform have its own scheduler source code.
It is impossible for us to integrate our framework for each existing platforms.
The listing \ref{lst:cpus-riot} shows a truncated list of all the supported platforms by RIOT OS.
Some of them are even written in Assembly code.

\begin{lstlisting}[style=ascii-tree, label={lst:cpus-riot}, caption={Truncated list of platforms supported by RIOT OS}]
cpu/
├── arm7_common
├── atmega1281
├── atmega1284p
(...)
├── stm32l1
└── stm32l4
\end{lstlisting}